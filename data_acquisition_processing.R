# ################################# ####
# Predicting Novel Communities      ####
# Author:    Timothy L Staples      ####
# Collaborators: John Pandolfi      #### 
#                Wolfgang Kiessling ####
# ################################# ####
# Script purpose ####
# Global attributes & working directories ####

rm(list=ls())

setwd("/home/timothy/Dropbox/Tim/Post-doc/Research projects/novel_comms_plants")

# path outside online repository to save large files generated by code. These are
# non-essential files and can be generated using this script, but it saves
# time to save then re-load them on subsequent executions.
large_file_path <- "/home/timothy/Dropbox/Tim/Post-doc/Large data files/novel_comms_plants"

# Global functions ####

# source functions from 'functions' sub-folder
sapply(paste0("./functions/", list.files("./functions")), source)

# Packages ####

package.loader(c("neotoma", "taxize", "taxizedb", "sp", "maptools", "rworldmap", "vegan",
                 "divDyn", "DHARMa", "nlme", "lme4", "fossil", "multcomp"))

# A little custom function to add dates to output files
date.wrap <- function(string, ext){
  paste0(string, " ", Sys.Date(), ext)
}

# ####
# 1. DATA IMPORT <- This takes a while ####
#           Download from Neotoma ####

# Download all vascular plant data from Neotoma, then save output (nested list) as 
# and .rds file.

http://api.neotomadb.org/v1/data/taxa?taxagroup=VPL

# taxatable <- get_table("Taxa")
# taxatable <- taxatable[taxatable$TaxaGroupID == "VPL", ]
# 
# plant.datasets <- get_dataset(taxonids = taxatable$TaxonID)

plant.datasets <- get_dataset(datasettype="pollen")

plant.records <- get_download(plant.datasets)

saveRDS(plant.records, file=paste0(large_file_path,
                                   "/Neotoma vascular plant records.rds"))

plant.records <- readRDS(paste0(large_file_path,
                                "/Neotoma vascular plant records.rds"))

#           Convert database tables into complete data-frame ####

# Convert nested-list SQL-form data to a data-frame with all data
# replicated on each row.

# So what we need to do is:
# - replicate sample.meta for each taxon present (from counts)
# - replicate dataset level data for each of these rows
# - combine each dataset record into a single data-frame (2979)

# this loops through each list entry and does the necessary processing, returning
# a data-frame
plant.record.df <- do.call("rbind", 
                           lapply(1:length(plant.records), 
                                  function(n){
  
  print(n)
  
  dataset <- plant.records[[n]]
  
  print(rownames(dataset$dataset[[1]])[1])

  # get taxon count per sample in data-frame form
  taxa.presence <- which(dataset$counts > 0, arr.ind=TRUE)
  
  # separate out where we our counts are a true matrix (multiple sites), or a 
  # single site (column matrix)
  if(dim(dataset$counts)[1] == 1){
  
  taxa.sample <- data.frame(taxon = colnames(dataset$counts)[taxa.presence[,2]],
                            sample.id = dataset$sample.meta$sample.id[1],
                            count = dataset$counts[taxa.presence])
  
  } else {
  
  taxa.sample <- data.frame(taxon = colnames(dataset$counts)[taxa.presence[,2]],
                            sample.id = rownames(dataset$counts)[taxa.presence[,1]],
                            count = dataset$counts[taxa.presence])
  
  }
  
  # Merge sample.meta data using sample.id to replicate sample-level data for
  # each taxa-sample row
  taxa.sample <- merge(taxa.sample, dataset$sample.meta,
                       by.x = "sample.id", by.y = "sample.id",
                       all.x = TRUE, all.y = FALSE)
  
  # now get the data-set level data from its nested-list into a data-frame.
  # removing date of data access, and stripping list names so they don't get
  # concatenated to the column names of the dataset
  dataset.noname <- dataset$dataset[names(dataset$dataset) != "access.date"]
  names(dataset.noname) = NULL
  metadata <- do.call("cbind", dataset.noname)
  
  # remove duplicated columns and those already present in taxa.sample data-frame
  metadata <- metadata[, !duplicated(colnames(metadata))]
  metadata <- metadata[, !colnames(metadata) %in% colnames(taxa.sample)]
  
  proc.dataset <- cbind(taxa.sample,
                        do.call("rbind", 
                          replicate(dim(taxa.sample)[1], 
                                    metadata, 
                                    simplify=FALSE)))

  return(proc.dataset)
  }))

# This is a big file, so I'm saving it to recall it to save having to redo this
# section of code each time
write.csv(plant.record.df, 
          paste0(large_file_path, "/Neotoma vascular plant records.csv"))

# ####
# 2. DATA CLEANING ####

#           Load Neotoma data ####

# read in imported data if it's not already in the global environment
if(! "plant.record.df" %in% ls()){
plant.record.df <- read.csv(paste0(large_file_path, 
                                   "/Neotoma vascular plant records.csv"))
}

#           Clean taxonomy ####
#                               Create taxa reference table ####

# My feeling is most of our cleaning will be at the taxa-level, excluding
# unknown Ids etc, and getting proper order/family/genus for each 'taxon'.

# this is going to be a bit of a process, but I'm going to split each
# taxon name into separate words, then try to bin taxon from fine to coarse
# taxonomic resolution.

# Get taxa master data-frame, with ID numbers so we can match our 
# final results back to our plant record dataframe
taxa.table <- data.frame(ID = 1:length(unique(plant.record.df$taxon)),
                         raw.taxon = unique(plant.record.df$taxon))

# remove punctuation
taxa.table$taxon<-gsub("[[:punct:]]"," ", taxa.table$raw.taxon)

#                               Create word-level taxa table ####

# By splitting each word in the taxon field, we can search for that specific
# word in lists of genera, families etc. This specific process lets us do this
# in a vectorized form which is much faster than scanning through words using
# substring sampling or using loops.

taxa.words <- strsplit(taxa.table$taxon, " ")
taxa.length <- unlist(mapply(ID = taxa.table$ID,
                      words = taxa.words, function(ID, words){
                        rep(ID, length(words))}))

taxa.words <- data.frame(taxon.word = unlist(taxa.words),
                         ID = taxa.length)

taxa.words <- taxa.words[!taxa.words$taxon.word %in% c("", " "), ]

#                               Download and compile The Plant List database ####

# this if statement saves us having to re-download and compile the database if it's
# already been done. It requires there to be a sub-directory in the large_file_path
# called "the_plant_list_databases" otherwise it will fail.
if(!"compiled TPL list.csv" %in% list.files(paste0(large_file_path, 
                                                  "/the_plant_list_databases"))){

# download The Plant List database so we can compare it to our dataset
tpl_get(paste0(large_file_path, "/the_plant_list_databases"))

# get list of files
family.list <- list.files(paste0(large_file_path, "/the_plant_list_databases"),
                          pattern = ".csv")

# one family doesn't have records, despite downloading a csv file. We need to
# fix these records in the "Resolve Taxonomic Issues" section below, thankfully
# though, this family has only a single genus
family.list <- family.list[!grepl("Isoëtaceae", family.list)]

tpl.df <- do.call("rbind", lapply(family.list, function(file){
                    print(file)
                    read.csv(paste0(large_file_path, "/the_plant_list_databases/",
                                    file))
                  }))

write.csv(tpl.df, paste0(large_file_path, "/the_plant_list_databases",
                           "/compiled TPL list.csv"))

} else { tpl.df <- read.csv(paste0(large_file_path, "/the_plant_list_databases",
                                   "/compiled TPL list.csv")) 
}

tpl.df<-tpl.df[order(tpl.df$Taxonomic.status.in.TPL),]

# instead of subsetting high confidence records, which might miss synonyms and
# revised names, I'm going to re-order the TPL database to have the accepted 
# names first for matching, then we'll examine the 'unresolved' names at the
# end to find synonyms

#                               Match genus ####

# Match each of our words to the genera in the TPL database
genus.match <- match(taxa.words$taxon.word, tpl.df$Genus)

# Either bring across the matched genus, or add NA
taxa.words$genus <- ifelse(is.na(genus.match),
                           NA,
                           as.character(tpl.df$Genus[genus.match]))

# Check for unresolved genus names
taxa.words$genus.status <- ifelse(is.na(genus.match),
                                  NA,
                                  as.character(tpl.df$Taxonomic.status.in.TPL[genus.match]))

# There's also one family that isn't indexed in TPL: Isoëtaceae (perhaps because of the 
# accented character?). Thankfully this family has a single genus (Isoëtes).
taxa.words$genus[taxa.words$taxon.word == "Isoëtes"] = "Isoetes"
taxa.words$genus.status[taxa.words$taxon.word == "Isoëtes"] = "Accepted"

# And another genus is listed in TPL without its accented character
taxa.words$genus[taxa.words$taxon.word == "Hippophaë"] = "Hippophae"
taxa.words$genus.status[taxa.words$taxon.word == "Hippophaë"] = "Accepted"

#                               Match family ####

# Bring across matched family names
family.match <- match(taxa.words$taxon.word, tpl.df$Family)

taxa.words$family <- ifelse(is.na(family.match),
                           NA,
                           as.character(tpl.df$Family[family.match]))


# Also search for families for genera we identified
genus.match <- match(taxa.words$taxon.word, tpl.df$Genus)

taxa.words$family[!is.na(genus.match)] <- 
  as.character(tpl.df$Family[genus.match[!is.na(genus.match)]])

# There are two families that are listed two ways:
# Asteraceae - Compositae
# Fabaceae - Leguminosae

# This isn't a problem for genus IDs, because we matched family name based on
# genus name, but there's a bunch of family-level IDs that weren't matched 
# because they used different family names.

taxa.words$family[taxa.words$taxon.word == "Asteraceae"] = "Compositae"
taxa.words$family[taxa.words$taxon.word == "Fabaceae"] = "Leguminosae"

# Also add the family name from the missing family
taxa.words$family[taxa.words$genus == "Isoetes" & 
                  !is.na(taxa.words$genus)] = "Isoetaceae"

# Double-check we don't have any unresolved families. Because we have combined
# two sources of family names (genus and family matches), we need to redo our
# match vector
family.match <- match(taxa.words$family, tpl.df$Family)

taxa.words$family.status <- ifelse(is.na(family.match),
                                  NA,
                                  as.character(tpl.df$Taxonomic.status.in.TPL[family.match]))

#                               Match phylum ####

# Do the same for phylum, searching for matched genera and families too
taxa.words$phylum = NA

taxa.words$phylum[!is.na(genus.match)] <- 
  as.character(tpl.df$Major.group[genus.match[!is.na(genus.match)]])

taxa.words$phylum[!is.na(family.match)] <- 
  as.character(tpl.df$Major.group[family.match[!is.na(family.match)]])

# There are some extra phylum-level IDs we should match
taxa.words$phylum[taxa.words$taxon.word == "Polypodiophyta"] = "P"
taxa.words$phylum[taxa.words$taxon.word == "Bryales"] = "B"
taxa.words$phylum[taxa.words$taxon.word == "Angiospermae"] = "A"
taxa.words$phylum[taxa.words$taxon.word == "Marchantiophyta"] = "B"

#                               Match species ####

# Matching species is more complex than the other processes because species name
# is often repeated in different genera. We'll need to match using both species
# and genera. Sometimes there are two genera or two species names listed in a
# taxon string, so we'll need to expand every combination of these to identify
# species

tpl.df$binom <- paste(tpl.df$Genus, tpl.df$Species)

species.words <- do.call("rbind", 
                         lapply(split(taxa.words, f=taxa.words$ID), function(x){

  # first, identify any unmatched words
  unmatched.words <- which(is.na(x$genus) & is.na(x$family) & is.na(x$phylum))
  
  # if there's no leftover words, return an NA for species
  if(length(unmatched.words)==0){return(NA)}
  
  # if there are leftover words, look for matches by combining every genus
  # with unmatched word
  species.words <- expand.grid(genus = x$genus,  
                               taxon.word = x$taxon.word[unmatched.words])
  
  species.match <- match(paste(species.words$genus, species.words$taxon.word),
                         tpl.df$binom)
  
  species.words$species <- ifelse(is.na(species.match),
                                  NA,
                                  as.character(tpl.df$Species[species.match]))
  
  # Now bring across the species status (accepted vs unresolved)
  species.words$species.status <- ifelse(is.na(species.match), NA,
                                         as.character(tpl.df$Taxonomic.status.in.TPL[species.match]))
  
  species.words <- species.words[!is.na(species.words$species) &
                                 !duplicated(species.words$species),]
  
  # if theres' an edge case where there's multiple species matches for one word
  # print an error message so we can debug
  if(sum(duplicated(species.words)) > 0){
    print(paste0("Duplicated matches in ID ", x$ID[1]))
    return(NULL)}
  
  # Finally, place the species and species status beside the appropriate word,
  # and return this data-frame
  merge(x, species.words[,c("taxon.word", "species", "species.status")],
              by.x = "taxon.word", by.y = "taxon.word", 
              all.x = TRUE, all.y = FALSE)
  
  }))

species.words <- species.words[!is.na(species.words$species), ]

species.words$tax.ID <- paste0(species.words$ID, ".", species.words$taxon.word)
taxa.words$tax.ID <- paste0(taxa.words$ID, ".", taxa.words$taxon.word)

taxa.words <- merge(taxa.words, species.words[,c("tax.ID", "species", "species.status")],
                     by.x = "tax.ID", by.y = "tax.ID",
                     all.x = TRUE, all.y = FALSE, sort = FALSE)
taxa.words <- taxa.words[order(taxa.words$ID), ]

#                               Resolve taxonomic issues ####
#                                         Synonyms ####
#                                                   Species ####

# Start with unresolved species, as we can resolve genera and families as a matter of course, then
# follow up with unresolved genera with no species IDs, and then with unresolved families with no
# genus IDs

# Do the same process for species, keeping track of 
unresolved.species <- taxa.words[taxa.words$species.status == "Unresolved" &
                                   !is.na(taxa.words$species),
                                 c("ID", "species")]

# we'll also need genus names for species, accounting for where there might be
# multiple genera named for a given taxon word
unresolved.species <- do.call("rbind", lapply(1:dim(unresolved.species)[1], 
                                              function(n){
                                                
                                                print(n)
                                                x<-unresolved.species[n,]
                                                
                                                temp.gen <- taxa.words$genus[taxa.words$ID == x[1,1] &
                                                                               !is.na(taxa.words$genus)]
                                                
                                                data.frame(ID = x[1,1],
                                                           genus = temp.gen,
                                                           species = x[1,2])
                                              }))

# remove duplicate binomial names
unresolved.species <- unresolved.species[!duplicated(paste(unresolved.species[,2],
                                                           unresolved.species[,3])), ]

# save file for manual processing
write.csv(unresolved.species, "./outputs/unresolved_species.csv")

# read in corrected names
resolved.species <- read.csv("./outputs/unresolved_species_resolved.csv",
                             stringsAsFactors = FALSE)

# Because these species matches rely on genus and species matching, we can only work at a taxon-ID
# level, and then we can work ID by ID to replace the appropriate names
taxa.words <- do.call("rbind", 
                      lapply(split(taxa.words, f=taxa.words$ID), 
                             function(x){
                               
                               print(x$ID[1])
                               
                               # Is it a genus on our unresolved species list?  
                               gen.name <- x$genus[x$genus %in% resolved.species$genus[resolved.species$genus %in% x$genus]]
                               gen.name <- gen.name[!duplicated(gen.name) & !is.na(gen.name)]
                               
                               # If it is, and we have a species ID
                               if(sum(x$genus %in% resolved.species$genus) > 0 &
                                  sum(!is.na(x$species)) > 0){
                                 
                                 sp.name <- x$species[x$species %in% resolved.species$species[resolved.species$genus %in% x$genus]]
                                 sp.name <- sp.name[!duplicated(sp.name) & !is.na(sp.name)]
                                 
                                 new.ind <- which(resolved.species$genus == gen.name &
                                                    resolved.species$species == sp.name)
                                 
                                 for(n in new.ind){
                                   
                                   old.gen <- resolved.species$genus[n]
                                   new.gen <- resolved.species$new.genus[n]
                                   old.sp <- resolved.species$species[n]
                                   new.sp <- resolved.species$new.species[n]
                                   sp.status <- resolved.species$new.species.status[n]
                                   
                                   x$genus[x$genus == old.gen & !is.na(x$genus)] = new.gen
                                   x$species.status[x$species == old.sp & !is.na(x$species)] = sp.status
                                   x$species[x$species == old.sp & !is.na(x$species)] = new.sp
                                   
                                 }
                                 
                               }
                               
                               return(x)
                               
                             }))

#                                                   Families ####

unresolved.families <- unique(taxa.words$family[taxa.words$family.status == "Unresolved" &
                                               !is.na(taxa.words$family)])
# None

#                                                   Genera ####

# Which genera are unresolved?
unresolved.genera <- unique(taxa.words$genus[taxa.words$genus.status == "Unresolved" &
                                             !is.na(taxa.words$genus)])

# Unfortunately, I can't find a way to automatically synonymize genera names, so
# we'll have to do this manually, one by one, also correcting species names as it happens.

# Export unresolved genera as .csv to run through Plant List

write.csv(data.frame(genus = unresolved.genera), "./outputs/unresolved genera.csv")

# Read in corrected genera
resolved.genera <- read.csv("./outputs/unresolved genera_resolved.csv")

genus.match <- match(taxa.words$genus, resolved.genera$genus)

# Keep old genera except for matches, then override with corrected genera
taxa.words$genus <- ifelse(is.na(genus.match),
                           taxa.words$genus,
                           as.character(resolved.genera$new.genus[genus.match]))

# Override genus.status for resolved genera
taxa.words$genus.status <- ifelse(is.na(genus.match),
                                  taxa.words$genus.status,
                                  as.character(resolved.genera$status[genus.match]))

#                               Aggregate word-level matches to taxa-level df ####

# convert these columns to characters for ease of processing (they are factors
# by default)
taxa.words[, c("genus", "family", "phylum", "species")] <- 
  do.call("cbind",
          lapply(taxa.words[,c("genus", "family", "phylum", "species")], 
                 as.character))

# This breaks down each taxon entry and summarises the genus, family and phylum.
# If there were no matched values, it returns NA. If there were multiple values,
# it looks for whether there is an accepted name, and picks that preferentially.
# If there's only an unresolved name, it returns that (with a status column so
# we can pick them out and resolve them manually).

# This is designed as a conservative process that only gives us an answer if 
# it was the only one found. E.g., if two genera were identified, we can only
# resolve the taxonomy to a family level.
taxa.words.proc <- do.call("rbind", 
                           lapply(split(taxa.words, f=taxa.words$ID), 
                                  function(x){
                                    
                                    # Do we have non-NAs?
                                    species.which <- which(!is.na(x$species))
                                    genus.which <- which(!is.na(x$genus))
                                    family.which <- which(!is.na(x$family))
                                    phylum.which <- which(!is.na(x$phylum))
                                    
                                    # Set up scalars to accept values
                                    species <- NA
                                    genus <- NA
                                    family <- NA
                                    phylum <- NA
                                    
                                    # if there's more than one match
                                    if(length(species.which) > 1 |
                                       length(genus.which) > 1 | 
                                       length(family.which) > 1 | 
                                       length(phylum.which) > 1){
                                      
                                      # get unique value (in case of duplicates) 
                                      # and exclude unresolved names
                                      species <- unique(x$genus[species.which][x$species.status[species.which] != "Unresolved"])
                                      genus <- unique(x$genus[genus.which][x$genus.status[genus.which] != "Unresolved"])
                                      family <- unique(x$family[family.which][x$family.status[family.which] != "Unresolved"])
                                      phylum <- unique(x$phylum[phylum.which])
                                      
                                    } else {
                                      
                                      # otherwise get the only value we have
                                      species <- x$species[species.which]
                                      genus <- x$genus[genus.which]
                                      family <- x$family[family.which]
                                      phylum <- x$phylum[phylum.which]
                                      
                                    }
                                    
                                    # if there's double-ups anywhere, or empty scalars, override them with NAs
                                    if(length(species) > 1 | length(species) == 0){ species = NA}  
                                    if(length(genus) > 1 | length(genus) == 0){ genus = NA}  
                                    if(length(family) > 1 | length(family) == 0){ family = NA}  
                                    if(length(phylum) > 1 | length(phylum) == 0){ phylum = NA}  
                                    
                                    
                                    data.frame(ID = x$ID[1],
                                               genus = genus,
                                               species = species,
                                               family = family,
                                               phylum = phylum,
                                               genus.status = ifelse(is.na(genus),
                                                                     NA,
                                                                     x$genus.status[x$genus == genus &
                                                                                      !is.na(x$genus)]),
                                               species.status = ifelse(is.na(species),
                                                                       NA,
                                                                       x$species.status[x$species == species &
                                                                                          !is.na(x$species)]),
                                               family.status = ifelse(is.na(family),
                                                                      NA,
                                                                      x$family.status[x$family == family &
                                                                                        !is.na(x$family)]))
                                    
                                  }))

#                               Merge taxonomy to records ####

# first merge taxonomy to our raw.taxon data-frame, so we can match our processed
# taxonomy to our paleo records data-frame.

taxa.table <- merge(taxa.table, taxa.words.proc,
                     by.x = "ID", by.y = "ID",
                     all.x = TRUE, all.y = TRUE, sort = FALSE)

taxa.count <- as.data.frame(table(plant.record.df$taxon))
colnames(taxa.count) <- c("raw.taxon", "count")

taxa.table <- merge(taxa.table, taxa.count,
                     by.x = "raw.taxon", by.y = "raw.taxon",
                     all.x = TRUE, all.y = TRUE, sort = FALSE)

write.csv(taxa.table, "./outputs/Neotoma taxa table.csv")

# now join new taxa to our plant records by matching the raw taxon
plant.record.df$taxon <- as.character(plant.record.df$taxon)
plant.record.df <- merge(plant.record.df,
                         taxa.table[,c("raw.taxon", "genus", "species", "family", "phylum")],
                         by.x = "taxon",
                         by.y = "raw.taxon",
                         all.x = TRUE, all.y = FALSE,
                         sort = FALSE)

#                               Taxonomy summary ####
taxonomy.summary <- rbind(species = table(!is.na(plant.record.df$species)),
                          genus = table(!is.na(plant.record.df$genus)),
                          family = table(!is.na(plant.record.df$family)),
                          phylum = table(!is.na(plant.record.df$phylum)))
rowSums(taxonomy.summary)

tax.summary.prop <- taxonomy.summary/ dim(plant.record.df)[1]

# Only 14% of species IDs, but nearly 67% have genus IDs

write.csv(plant.record.df, paste0(large_file_path,"/processed_neotoma_records.csv"))

# 3. DUPLICATE CHECK ####

plant.record.df <- read.csv(paste0(large_file_path, "/Neotoma vascular plant records.csv"))

plant.record.df <- plant.record.df[!plant.record.df$taxon %in% c("Bryophyta", "Botryococcus", 
                                                                 "Scenedesmus", "Pediastrum",
                                                                 "Pteridophyta (monolete) undiff.",
                                                                 "Isoëtes", "Tetraëdron",
                                                                 "Algae undiff."),]

head(plant.record.df)

a <- tapply(plant.record.df$count, plant.record.df$sample.id, sum)
summary(a)

sub <- 


sub <- plant.record.df[plant.record.df$site.name == "Moossee" &
                         !is.na(plant.record.df$sample.id),]
summary(tapply(sub$count, sub$sample.id, sum))
